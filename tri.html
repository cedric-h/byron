<!-- vim: sw=2 ts=2 expandtab smartindent ft=javascript
-->
<style>
  * {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
</style>
<script type="module">
window.onload = () => {
  const canvas = document.body.appendChild(document.createElement('canvas'));
  const gl = canvas.getContext('webgl');

  (window.onresize = () => {
    gl.viewport(
      0,
      0,
      canvas.width = window.innerWidth,
      canvas.height = window.innerHeight
    );
  })();

  let shader_program;
  {
    const vs_source = `
      attribute vec2 a_pos;
      varying vec2 v_uv;

      void main() {
        gl_Position = vec4(a_pos, 0, 1);
        v_uv = 0.5*(a_pos + vec2(1));
      }
    `;
    const fs_source = `
      precision lowp float;

      uniform sampler2D u_tex;

      varying vec2 v_uv;

      void main() {
        // gl_FragColor = vec4(0.5 + 0.5*cos(v_uv.xyx+vec3(0,2,4)), 1);
        gl_FragColor = vec4(texture2D(u_tex, v_uv).xyz, 1);
      }
    `;

    function load_shader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error("An error occurred compiling the shaders: " + info);
        return null;
      }

      return shader;
    }
    const vertex_shader = load_shader(gl, gl.VERTEX_SHADER, vs_source);
    const fragment_shader = load_shader(gl, gl.FRAGMENT_SHADER, fs_source);

    shader_program = gl.createProgram();
    gl.attachShader(shader_program, vertex_shader);
    gl.attachShader(shader_program, fragment_shader);
    gl.linkProgram(shader_program);
    gl.useProgram(shader_program);
  }

  const tribuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tribuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  /* location, number of components, type, normalize, stride, offset */
  const a_pos = gl.getUniformLocation(shader_program, 'u_pos');
  gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_pos);

  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // fill texture with 3x2 pixels
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0,
                gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([ 128,  64,   0, 255,
                                 128,   0,   0, 255,
                                 128, 128,   0, 255,
                                  64,  64,   0, 255]));

  // set the filtering so we don't need mips and it's not filtered
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  /* [x] sample image
   * [ ] render tri in points

   * [ ] sample render target */

  requestAnimationFrame(function animate(time) {
    requestAnimationFrame(animate);
    gl.uniform1i(gl.getUniformLocation(shader_program, 'u_tex'), 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  });
}
</script>
