<!-- vim: sw=2 ts=2 expandtab smartindent
-->
<style>
  * {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
</style>
<script type="module">
window.onload = () => {
  const canvas = document.body.appendChild(document.createElement('canvas'));
  const gl = canvas.getContext('webgl2');

  let shader_program;
  {
    const vs_source = `#version 300 es
      out vec2 vUv;

      const vec2 position[3] = vec2[](vec2(-1), vec2(3, -1), vec2(-1, 3));
      const vec2 uv[3] = vec2[](vec2(0), vec2(2, 0), vec2(0, 2));

      void main() {
        gl_Position = vec4(position[gl_VertexID], 0, 1);
        vUv = uv[gl_VertexID];
      }
    `;
    const fs_source = `#version 300 es
      precision lowp float;

      uniform float u_time;

      in vec2 vUv;
      out vec4 color;

      void main() {
        color = vec4(.3, .2, .5, 1);
        color.rgb += .5 + .3 * cos(vUv.xyx + u_time);
      }
    `;

    function load_shader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error("An error occurred compiling the shaders: " + info);
        return null;
      }

      return shader;
    }
    const vertex_shader = load_shader(gl, gl.VERTEX_SHADER, vs_source);
    const fragment_shader = load_shader(gl, gl.FRAGMENT_SHADER, fs_source);

    shader_program = gl.createProgram();
    gl.attachShader(shader_program, vertex_shader);
    gl.attachShader(shader_program, fragment_shader);
    gl.linkProgram(shader_program);
    gl.useProgram(shader_program);
  }

  requestAnimationFrame(function animate(time) {
    requestAnimationFrame(animate);
    gl.uniform1f(gl.getUniformLocation(shader_program, 'u_time'), time / 1000);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  });
}
</script>
